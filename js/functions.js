//
// Задания с текущей страницы
// https://up.htmlacademy.ru/profession/react-js-individual/1/javascript-individual/1/tasks/6#
//
//Мои комментарии, по тестам со страницы заданий все ок
//Тестировал код в терминале htmlacademy

// -------------------------------
// 1-я функция
//Функция для проверки, является ли строка палиндромом. Палиндром — это слово или фраза, которые одинаково читаются и слева направо и справа налево. Например:

//Вырезание пробелов - вспомогательная функция, линтер ругнулся, сказал передвинуть наверх, я ее изначально размещал ниже основной функции
const cutingSpaces = (strWithSpaces) => {
  const tempStr = [];
  //console.log('!!!');
  //console.log(strWithSpaces);

  for(let i = 0; i <= strWithSpaces.length - 1; i++) {
    if(strWithSpaces[i] !== ' ') {
      tempStr.push(strWithSpaces[i]);
    }
  }

  return tempStr;

};

const checkWord = (str) => {

  //[нужно сначала делать join, а потом reverse, потому что сейчас функция работает не правильно если в строке больше одного слова]
  //-Не совсем понятно почему join первым, join же собирает строку из массива. Я пытался поставить впереди, он выдает ошибки. Попробовал удлинить фразы, как я сделал, работает. Ниже примеры в вызове функций.

  //переворачиваем слово
  let reverse = str.split(''); //Разбиваем массив на элементы
  str = reverse;

  //Вызов функции по вырезанию пробелов
  reverse = cutingSpaces(reverse);
  str = cutingSpaces(str);

  //Реверс и соединение массивов
  reverse = reverse.reverse().join('');
  str = str.join('');

  //убираем разные регистры
  str = str.toLowerCase();
  reverse = reverse.toLowerCase();

  return str === reverse;

};


//Доп. задание
checkWord('Лёша на полке клопа нашёл ');
// Строка является палиндромом
//checkWord('топот топот'); // true
//checkWord('топот'); // true
// Несмотря на разный регистр, тоже палиндром
//checkWord('ДовОд'); // true
// Это не палиндром
//checkWord('Кекс');  // false


// -------------------------
// 2-я функция
// Функция, которая принимает строку, извлекает содержащиеся в ней цифры от 0 до 9 и возвращает их в виде целого положительного числа. Если в строке нет ни одной цифры, функция должна вернуть NaN:

const extractingNumbers = (str) => {
  let newStr = '';

  for (let i = 0; i < str.length; i++) {
    //проверка на число
    if(!isNaN(str[i]) && str[i] !== ' '){
      //значит символ
      newStr = newStr + str[i];
    }
  }
  //console.log(newStr);
  if(newStr === '') {
    return NaN;
  } else {

    newStr = parseInt(newStr, 10);
    return newStr; //С записанными цифрами
  }
};


extractingNumbers('2023 год'); // 2023
// extractingNumbers('ECMAScript 2022');     // 2022
//extractingNumbers('1 кефир, 0.5 батона'); // 105
// extractingNumbers('агент 007');           // 7
// extractingNumbers('а я томат');           // NaN


// --------------------
//3-я функция
// Функция, которая принимает три параметра: исходную строку, минимальную длину и строку с добавочными символами — и возвращает исходную строку, дополненную указанными символами до заданной длины. Символы добавляются в начало строки. Если исходная строка превышает заданную длину, она не должна обрезаться. Если «добивка» слишком длинная, она обрезается с конца.
// Эта функция нам пригодится для формирования адресов файлов. Примеры её использования:

const createNewStr = (str,maxLength,newStr) => {

  const tempStr = str;


  if(newStr.length > maxLength) {

    //обрезаем добавочное
    str = newStr.slice(0, maxLength - 1) + str;
    //console.log(newStr);
    //console.log(str);

  } else {
    // console.log(newStr);
    //console.log(str);
    //Исходное не нужно резать
    if(str.length < maxLength) {
    //Размножение недостающих добавочных
      for(let i = 1; i < maxLength;
        i++){
        if(str.length > maxLength) {
          str = str.slice(0,maxLength - 1) + tempStr;
          break;
        } else {
          str = newStr + str;
        }
      }
    }

  }

  return str;
  //console.log(str);
};

// Добавочный символ использован один раз
//createNewStr('1', 2, '0'); // '01'

// Добавочный символ использован три раза
//createNewStr('1', 4, '0');      // '0001'

// Добавочные символы обрезаны с концаA
//createNewStr('q', 4, 'werty');  // 'werq'

// Добавочные символы использованы полтора раза
//createNewStr('q', 4, 'we');     // 'wweq' - у меня wewq, но я руководствовался заданием, см. след. строку
//Если «добивка» слишком длинная, она обрезается с конца.

// Добавочные символы не использованы, исходная строка не изменена
createNewStr('qwerty', 4, '0'); // 'qwerty'


//-------------
// 4-я функция
// Функция для проверки длины строки. Она принимает строку, которую нужно проверить, и максимальную длину и возвращает true, если строка меньше или равна указанной длине, и false, если строка длиннее. Эта функция нам пригодится для валидации формы. Примеры использования функции:

//[и ошибки линтера исправь]


const checkStr = (strOriginal,maxNumber) => strOriginal.length <= maxNumber;

// Cтрока короче 20 символов
checkStr('проверяемая строка', 20); // true
// Длина строки ровно 18 символов
//checkStr('проверяемая строка', 18); // true
// Строка длиннее 10 символов
//checkStr('проверяемая строка', 10); // false
